# -*- coding: utf-8 -*-
"""
/***************************************************************************
 massprintlab
                                 A QGIS plugin
 -
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-01-17
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Grigory Nevsky, LabGrad
        email                : nevskygrigory@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from enum import Enum
from typing import List

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

from qgis.core import QgsProject, QgsLayoutExporter,QgsUnitTypes
from qgis.utils import *
from PyQt5 import QtCore, QtGui, QtWidgets


# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .massprintlab_dialog import massprintlabDialog
import os.path

import numpy as np
from datetime import date, time, datetime
import math

class FileType(Enum):
    pdf = 'pdf'
    png = 'png'


class massprintlab:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'massprintlab_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&massprintlab')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('massprintlab', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/massprintlab/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&massprintlab'),
                action)
            self.iface.removeToolBarIcon(action)



    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = massprintlabDialog()

        # задание списка возможных форматов вывода на печать
        format_list = ['png', 'pdf']

        # задание списка масштабного ранжирования
        scalerange_rule_list = ['линейная шкала', 'логарифмическая шкала']

        # задание операторов для фильтра
        filter_operators = ['None', '=', '!=', '<', '<=','>', '>=', 'LIKE', 'ILIKE', '%', 'IN', 'NOT IN']

        # словарь единиц измерения
        UnitsPerSegment_dict = {'метры': 0, 'километры': 1}

        # получение списка макетов в проекте
        curLayouts = QgsProject.instance().layoutManager().layouts()
        layout_list = []
        for layout in curLayouts:
            layout_list.append(layout.name())



        def select_output_file():
            file_path = QtWidgets.QFileDialog.getExistingDirectory(self.dlg, "Выбери папку для записи ", "")
            self.dlg.lineEdit_saver.setText(f'{file_path}')

        def defQuery():
            layer = self.dlg.mMapLayerComboBox_mf_lay.currentLayer()
            iface.setActiveLayer(layer)
            iface.zoomToActiveLayer()
            field_1 = self.dlg.mFieldComboBox_mf_lay.currentField()

            layer_dp = layer.dataProvider()
            layer_unique = list(layer_dp.uniqueValues(layer_dp.fieldNameIndex(field_1)))
            return layer_unique, layer, field_1



        def namer():
            #надо переписать, сейчас в качестве примера имени выводится любое уникальное значение из определённого столбца слоя
            #надо, чтобы выводилось значения полей от одной строки (объекта)
            self.dlg.lineEdit_namer.clear()
            layer = self.dlg.mMapLayerComboBox_namer.currentLayer()
            layer_dp = layer.dataProvider()
            field_namer_1 = self.dlg.mFieldComboBox_namer_1.currentField()
            field_namer_2 = self.dlg.mFieldComboBox_namer_2.currentField()
            field_namer_3 = self.dlg.mFieldComboBox_namer_3.currentField()
            field_namer_4 = self.dlg.mFieldComboBox_namer_4.currentField()

            try:
                field_namer_1_value = list(layer_dp.uniqueValues(layer_dp.fieldNameIndex(field_namer_1)))[0]
            except:
                field_namer_1_value = ''
            try:
                field_namer_2_value = list(layer_dp.uniqueValues(layer_dp.fieldNameIndex(field_namer_2)))[0]
            except:
                field_namer_2_value = ''
            try:
                field_namer_3_value = list(layer_dp.uniqueValues(layer_dp.fieldNameIndex(field_namer_3)))[0]
            except:
                field_namer_3_value = ''
            try:
                field_namer_4_value = list(layer_dp.uniqueValues(layer_dp.fieldNameIndex(field_namer_4)))[0]
            except:
                field_namer_4_value = ''

            list_values = np.array([field_namer_1_value, field_namer_2_value,
                                    field_namer_3_value, field_namer_4_value])
            list_values = list_values[list_values != '']

            self.dlg.lineEdit_namer.setText('_'.join(list_values))
            return '_'.join(list_values)

        def scale_range_selector():
            scale_step = self.dlg.mQgsSpinBox_scale.value()
            max_scale = int(self.dlg.mScaleRangeWidget.maximumScale())
            min_scale = int(self.dlg.mScaleRangeWidget.minimumScale())
            scale_range = [i for i in range(max_scale, min_scale + scale_step
                                            , scale_step)]
            if self.dlg.comboBox_range_rule.currentIndex() == 0:
                self.dlg.lineEdit_scalerange.setText(str(scale_range))
            else:
                base = max_scale
                end_scale = min_scale
                stop = math.log(end_scale, base)
                num = self.dlg.mQgsSpinBox_scale_2.value()
                scale_range = np.logspace(1, stop=stop, num=num, endpoint=True, base=base, dtype=int, axis=0)
                scale_range = np.around(scale_range, -2)
                self.dlg.lineEdit_scalerange.setText(str(scale_range))
            return scale_range

        # filter function
        def filt_by_iddb(layer, filter_field, value):
            layer.setSubsetString(f'"{filter_field}" = {value}')
            iface.setActiveLayer(layer)
            iface.zoomToActiveLayer()
            return layer.extent()

        def scale_setter(max_scale, min_scale, cur_scale_value, scale_range):
            if (np.array(
                    scale_range) >= cur_scale_value).all():  # если все значения масштаба больше текущего масштаба
                return max_scale
            elif (np.array(
                    scale_range) <= cur_scale_value).all():  # если все значения масштаба меньше текущего масштаба
                return min_scale
            return np.array(scale_range)[np.array(scale_range) >= cur_scale_value][0]


        def aux_filter(layer, field, operator, link_lay, link_lay_field):

            link_lay_dp = link_lay.dataProvider()
            if link_lay_dp.featureCount() > 1:
                linked_layer_field_values = str(link_lay_dp.uniqueValues(
                link_lay_dp.fieldNameIndex(link_lay_field))).replace('{', '(').replace('}', ')')
            else:
                linked_layer_field_index = link_lay_dp.fieldNameIndex(link_lay_field)
                linked_layer_field_values = \
                    [feature.attributes()[linked_layer_field_index] for feature in link_lay_dp.getFeatures()][0]
                if linked_layer_field_values == '':
                    linked_layer_field_values = "('zero_value')"

            print(f"linked_layer_field_values {linked_layer_field_values}")
            print(f'"{field}" {operator} {linked_layer_field_values}')
            layer.setSubsetString(f'"{field}" {operator} {linked_layer_field_values}')




        self.dlg.lineEdit_saver.clear()
        self.dlg.toolButton_saver.clicked.connect(select_output_file)

        self.dlg.comboBox_layout.clear()
        self.dlg.comboBox_layout.addItems(layout_list)

        self.dlg.comboBox_saver.clear()
        self.dlg.comboBox_saver.addItems(format_list)

        self.dlg.comboBox_range_rule.clear()
        self.dlg.comboBox_range_rule.addItems(scalerange_rule_list)

        # show the dialog
        self.dlg.show()


        #main_filter
        self.dlg.mMapLayerComboBox_mf_lay.layerChanged.connect(self.dlg.mFieldComboBox_mf_lay.setLayer)

        # auxiliary_filter
        self.dlg.mMapLayerComboBox_layer_1.layerChanged.connect(self.dlg.mFieldComboBox_layer_1.setLayer)
        self.dlg.comboBox_operator_1.addItems(filter_operators)
        self.dlg.mMapLayerComboBox_l_lay_1.layerChanged.connect(self.dlg.mFieldComboBox_l_lay_1.setLayer)

        self.dlg.mMapLayerComboBox_layer_2.layerChanged.connect(self.dlg.mFieldComboBox_layer_2.setLayer)
        self.dlg.comboBox_operator_2.addItems(filter_operators)
        self.dlg.mMapLayerComboBox_l_lay_2.layerChanged.connect(self.dlg.mFieldComboBox_l_lay_2.setLayer)

        self.dlg.mMapLayerComboBox_layer_3.layerChanged.connect(self.dlg.mFieldComboBox_layer_3.setLayer)
        self.dlg.comboBox_operator_3.addItems(filter_operators)
        self.dlg.mMapLayerComboBox_l_lay_3.layerChanged.connect(self.dlg.mFieldComboBox_l_lay_3.setLayer)



        # namer
        self.dlg.pushButton_namer.clicked.connect(namer)
        self.dlg.mMapLayerComboBox_namer.layerChanged.connect(self.dlg.mFieldComboBox_namer_1.setLayer)
        self.dlg.mMapLayerComboBox_namer.layerChanged.connect(self.dlg.mFieldComboBox_namer_2.setLayer)
        self.dlg.mMapLayerComboBox_namer.layerChanged.connect(self.dlg.mFieldComboBox_namer_3.setLayer)
        self.dlg.mMapLayerComboBox_namer.layerChanged.connect(self.dlg.mFieldComboBox_namer_4.setLayer)

        self.dlg.pushButton_scale.clicked.connect(scale_range_selector)


        self.dlg.comboBox_ruler_units.clear()
        self.dlg.comboBox_ruler_units.addItems(UnitsPerSegment_dict.keys())

        # Run the dialog event loop
        result = self.dlg.exec_()

        max_scale = int(self.dlg.mScaleRangeWidget.maximumScale())
        min_scale = int(self.dlg.mScaleRangeWidget.minimumScale())
        scale_range = scale_range_selector()

        ruler_min = self.dlg.mQgsSpinBox_ruler_min.value() / (2 * 10 ** 6)
        ruler_max = self.dlg.mQgsSpinBox_ruler_max.value() / (2 * 10 ** 6)
        units_per_segment = np.array([0.1, 0.25, 0.5, 1, 2, 2.5, 5, 10, 20])


        # See if OK was pressed
        if result:
            selected_layout = curLayouts[self.dlg.comboBox_layout.currentIndex()]
            referencemap = selected_layout.referenceMap()
            referencebar = selected_layout.itemById("scalebar")
            layer_unique, layer, filter_field = defQuery()
            base_path = self.dlg.lineEdit_saver.text()
            file_ext = format_list[self.dlg.comboBox_saver.currentIndex()]


            try:
                os.mkdir(os.path.join(base_path, str(date.today()).replace('-', '_')))
                write_path = os.path.join(base_path, str(date.today()).replace('-', '_'))
            except FileExistsError:
                write_path = os.path.join(base_path, str(date.today()).replace('-', '_'))

            print(write_path)

            os.mkdir(os.path.join(write_path, datetime.now().strftime('%H:%M').replace(':', '_')))

            write_path = os.path.join(write_path, datetime.now().strftime('%H:%M').replace(':', '_'))

            file = open(write_path + '/log.txt', 'w')
            file.write(f'ЭТО ЛОГ ФАЙЛ, в папке должно быть {len(layer_unique)} файлов')
            file.close()

            if self.dlg.comboBox_ruler_units.currentIndex() == 0:
                units_per_segment = units_per_segment * 1000
                ruler_max = ruler_max * 1000
                ruler_min = ruler_min * 1000



            for value in layer_unique:

                extent = filt_by_iddb(layer, filter_field, value)

                if filter_operators[self.dlg.comboBox_operator_1.currentIndex()] != 'None':
                    aux_filter(self.dlg.mMapLayerComboBox_layer_1.currentLayer(),
                     self.dlg.mFieldComboBox_layer_1.currentField(),
                     filter_operators[self.dlg.comboBox_operator_1.currentIndex()],
                     self.dlg.mMapLayerComboBox_l_lay_1.currentLayer(),
                     self.dlg.mFieldComboBox_l_lay_1.currentField())

                if filter_operators[self.dlg.comboBox_operator_2.currentIndex()] != 'None':
                    aux_filter(self.dlg.mMapLayerComboBox_layer_2.currentLayer(),
                     self.dlg.mFieldComboBox_layer_2.currentField(),
                     filter_operators[self.dlg.comboBox_operator_2.currentIndex()],
                     self.dlg.mMapLayerComboBox_l_lay_2.currentLayer(),
                     self.dlg.mFieldComboBox_l_lay_2.currentField())

                if filter_operators[self.dlg.comboBox_operator_3.currentIndex()] != 'None':
                    aux_filter(self.dlg.mMapLayerComboBox_layer_3.currentLayer(),
                     self.dlg.mFieldComboBox_layer_3.currentField(),
                     filter_operators[self.dlg.comboBox_operator_3.currentIndex()],
                     self.dlg.mMapLayerComboBox_l_lay_3.currentLayer(),
                     self.dlg.mFieldComboBox_l_lay_3.currentField())


                full_file_path = f"{write_path}/{namer()}.{file_ext}"
                iface.openLayoutDesigner(selected_layout)
                selected_layout.refresh()
                referencemap.zoomToExtent(extent)

                cur_scale_value = referencemap.scale()
                cur_scale_value = scale_setter(max_scale, min_scale, cur_scale_value, scale_range)
                referencemap.setScale(cur_scale_value)
                units_per_segment_value = units_per_segment[
                    np.where((units_per_segment / cur_scale_value >= ruler_min) & \
                             (units_per_segment / cur_scale_value <= ruler_max))].max()
                referencebar.setUnitsPerSegment(units_per_segment_value)

                exporter = QgsLayoutExporter(selected_layout)
                if format_list[self.dlg.comboBox_saver.currentIndex()] == 'png':
                    exporter.exportToImage(full_file_path, QgsLayoutExporter.ImageExportSettings())
                elif format_list[self.dlg.comboBox_saver.currentIndex()] == 'pdf':
                    exporter.exportToPdf(full_file_path, QgsLayoutExporter.PdfExportSettings())
                else:
                    print('Неизвестный формат')
                    break